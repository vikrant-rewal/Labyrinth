<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Classic Wood Labyrinth</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #1a0f05 0%, #2d1810 50%, #1a0f05 100%);
            font-family: 'Georgia', serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        #gameCanvas {
            display: block;
            border-radius: 50%;
            box-shadow: 
                0 0 0 8px #5d4037,
                0 0 0 12px #3e2723,
                0 0 60px rgba(0,0,0,0.8),
                0 0 100px rgba(139,90,43,0.3);
        }
        .overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(15, 8, 3, 0.95);
            color: #e3c099;
            z-index: 20;
            transition: opacity 0.4s ease;
            backdrop-filter: blur(8px);
        }
        h1 {
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 6px;
            color: #d4a76a;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 20px rgba(212,167,106,0.4);
        }
        p {
            font-size: 1rem;
            color: #a1887f;
            margin-bottom: 2rem;
            max-width: 85%;
            text-align: center;
            line-height: 1.6;
        }
        button {
            padding: 18px 56px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            background: linear-gradient(to bottom, #e8c896, #c4956a);
            color: #2b1d0e;
            border: none;
            border-radius: 40px;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 8px 0 #8b5a2b, 0 15px 30px rgba(0,0,0,0.5);
            transition: all 0.15s ease;
        }
        button:hover { transform: translateY(-2px); }
        button:active { transform: translateY(6px); box-shadow: 0 2px 0 #8b5a2b; }
        #hud {
            position: fixed;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 10;
        }
        #timerBadge {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 25px;
            color: #fff;
            font-weight: 700;
            font-size: 1rem;
            border: 1px solid rgba(255,255,255,0.15);
        }
        .hidden { opacity: 0; pointer-events: none; }
        #instructions {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="hud"><span id="timerBadge">00:00 | 0/3</span></div>
    <div id="instructions">Tilt to roll • Tap to recalibrate • Arrow keys / WASD fallback</div>
    
    <div id="startScreen" class="overlay">
        <h1>Labyrinth</h1>
        <p>Guide all 3 steel balls through the maze to the center goal.<br>Tilt your device or use arrow keys.</p>
        <label style="display:flex; gap:0.6rem; align-items:center; margin:0.5rem 0 0; font-size:0.9rem; color:#d2b48c;">
            <input type="checkbox" id="toggleLockGoal">
            Lock balls in goal (easier mode)
        </label>
        <button id="btnStart">Play & Enable Motion</button>
        <p id="motionStatus" style="margin-top:1rem; font-size:0.9rem; color:#bca490;"></p>
    </div>

    <div id="winScreen" class="overlay hidden">
        <h1 style="color:#a5d6a7">Victory!</h1>
        <p>All balls secured in <span id="finalTime" style="color:#fff; font-weight:bold;"></span></p>
        <button id="btnRestart">Play Again</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
const CONFIG = {
    RINGS: 7,
    SECTORS: 12,
    BALL_COUNT: 3,
    WALL_WIDTH: 4,
    BALL_RADIUS: 6,
    FRICTION: 0.996,
    TILT_SENSITIVITY: 0.36,
    MAX_VELOCITY: 5.2,
    SUB_STEPS: 16
};

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const PI2 = Math.PI * 2;

let width, height, centerX, centerY, maxRadius;
let gameState = { playing: false, won: false, startTime: 0, timeStr: "00:00" };
let tilt = { x: 0, y: 0 };
let calibration = { beta: 0, gamma: 0, ready: false };
let motionDetected = false;
let motionHintTimeout = null;
let lockGoalEnabled = false;
let balls = [];
let walls = [];
let goalRadius, ringWidth, sectorAngle;

const keys = { left: false, right: false, up: false, down: false };

function init() {
    resize();
    window.addEventListener('resize', resize);
    document.getElementById('btnStart').addEventListener('click', requestPermissions);
    document.getElementById('btnRestart').addEventListener('click', startGame);
    canvas.addEventListener('pointerdown', () => {
        if (gameState.playing) {
            calibration.ready = false;
        }
    });
    window.addEventListener('deviceorientation', handleOrientation);
    window.addEventListener('devicemotion', () => { motionDetected = true; }, { passive: true });
    
    window.addEventListener('keydown', e => {
        if(['ArrowLeft','a','A'].includes(e.key)) keys.left = true;
        if(['ArrowRight','d','D'].includes(e.key)) keys.right = true;
        if(['ArrowUp','w','W'].includes(e.key)) keys.up = true;
        if(['ArrowDown','s','S'].includes(e.key)) keys.down = true;
        e.preventDefault();
    });
    window.addEventListener('keyup', e => {
        if(['ArrowLeft','a','A'].includes(e.key)) keys.left = false;
        if(['ArrowRight','d','D'].includes(e.key)) keys.right = false;
        if(['ArrowUp','w','W'].includes(e.key)) keys.up = false;
        if(['ArrowDown','s','S'].includes(e.key)) keys.down = false;
    });
    
    requestAnimationFrame(loop);
}

function resize() {
    const size = Math.min(window.innerWidth, window.innerHeight, 580) - 30;
    width = height = size;
    canvas.width = canvas.height = size;
    centerX = centerY = size / 2;
    maxRadius = size * 0.48;
    goalRadius = maxRadius * 0.18;
    ringWidth = (maxRadius - goalRadius) / CONFIG.RINGS;
    sectorAngle = PI2 / CONFIG.SECTORS;
}

function generateMaze() {
    walls = [];
    
    // Create grid [ring][sector]
    const grid = [];
    for (let r = 0; r < CONFIG.RINGS; r++) {
        grid[r] = [];
        for (let s = 0; s < CONFIG.SECTORS; s++) {
            grid[r][s] = {
                innerWall: true,
                cwWall: true,
                visited: false
            };
        }
    }
    
    // Start maze generation from center and work outward
    // This ensures paths radiate from center
    const startSector = Math.floor(Math.random() * CONFIG.SECTORS);
    
    const stack = [];
    let current = { r: 0, s: startSector };
    grid[current.r][current.s].visited = true;
    
    function getUnvisitedNeighbors(r, s) {
        const neighbors = [];
        
        // Inner neighbor
        if (r > 0 && !grid[r-1][s].visited) {
            neighbors.push({ r: r-1, s: s, dir: 'inner' });
        }
        
        // Outer neighbor
        if (r < CONFIG.RINGS - 1 && !grid[r+1][s].visited) {
            neighbors.push({ r: r+1, s: s, dir: 'outer' });
        }
        
        // CCW neighbor
        const ccw = (s - 1 + CONFIG.SECTORS) % CONFIG.SECTORS;
        if (!grid[r][ccw].visited) {
            neighbors.push({ r: r, s: ccw, dir: 'ccw' });
        }
        
        // CW neighbor
        const cw = (s + 1) % CONFIG.SECTORS;
        if (!grid[r][cw].visited) {
            neighbors.push({ r: r, s: cw, dir: 'cw' });
        }
        
        return neighbors;
    }
    
    function removeWallBetween(fromR, fromS, toR, toS, dir) {
        if (dir === 'inner') {
            grid[fromR][fromS].innerWall = false;
        } else if (dir === 'outer') {
            grid[toR][toS].innerWall = false;
        } else if (dir === 'cw') {
            grid[fromR][fromS].cwWall = false;
        } else if (dir === 'ccw') {
            grid[toR][toS].cwWall = false;
        }
    }
    
    // Recursive backtracker
    while (true) {
        const neighbors = getUnvisitedNeighbors(current.r, current.s);
        
        if (neighbors.length > 0) {
            const next = neighbors[Math.floor(Math.random() * neighbors.length)];
            stack.push(current);
            removeWallBetween(current.r, current.s, next.r, next.s, next.dir);
            current = { r: next.r, s: next.s };
            grid[current.r][current.s].visited = true;
        } else if (stack.length > 0) {
            current = stack.pop();
        } else {
            break;
        }
    }
    
    // Open multiple paths to goal from innermost ring (ring 0)
    // This ensures all balls can reach the center
    const exitCount = 1;
    const usedSectors = new Set();
    for (let i = 0; i < exitCount; i++) {
        let exitSector;
        do {
            exitSector = Math.floor(Math.random() * CONFIG.SECTORS);
        } while (usedSectors.has(exitSector));
        usedSectors.add(exitSector);
        grid[0][exitSector].innerWall = false;
    }
    
    // Convert grid to walls
    for (let r = 0; r < CONFIG.RINGS; r++) {
        const innerR = goalRadius + r * ringWidth;
        const outerR = goalRadius + (r + 1) * ringWidth;
        
        for (let s = 0; s < CONFIG.SECTORS; s++) {
            const cell = grid[r][s];
            const startAngle = s * sectorAngle;
            const endAngle = (s + 1) * sectorAngle;
            
            // Inner arc wall
            if (cell.innerWall) {
                const arcPad = r === 0 ? 0.03 : 0.06;
                walls.push({
                    type: 'arc',
                    radius: innerR,
                    startAngle: startAngle + arcPad,
                    endAngle: endAngle - arcPad
                });
            }
            
            // CW radial wall
            if (cell.cwWall) {
                walls.push({
                    type: 'radial',
                    angle: endAngle,
                    innerR: innerR + 1,
                    outerR: outerR - 1
                });
            }
        }
    }
    
    // Outer boundary
    walls.push({ type: 'boundary', radius: maxRadius });
    
    // Spawn balls spread around the outer ring
    balls = [];
    for (let i = 0; i < CONFIG.BALL_COUNT; i++) {
        const sector = Math.floor((i / CONFIG.BALL_COUNT) * CONFIG.SECTORS + CONFIG.SECTORS / (CONFIG.BALL_COUNT * 2));
        const spawnAngle = (sector + 0.5) * sectorAngle;
        const spawnR = goalRadius + (CONFIG.RINGS - 0.5) * ringWidth;
        
        balls.push({
            x: centerX + Math.cos(spawnAngle) * spawnR,
            y: centerY + Math.sin(spawnAngle) * spawnR,
            vx: 0, vy: 0,
            r: CONFIG.BALL_RADIUS,
            inGoal: false,
            locked: false
        });
    }
}

function startGame() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('winScreen').classList.add('hidden');
    updateMotionStatus('');
    lockGoalEnabled = document.getElementById('toggleLockGoal')?.checked ?? false;
    resize();
    generateMaze();
    gameState = { playing: true, won: false, startTime: Date.now(), timeStr: "00:00" };
    tilt = { x: 0, y: 0 };
    calibration = { beta: 0, gamma: 0, ready: false };
    motionDetected = false;
    if (motionHintTimeout) {
        clearTimeout(motionHintTimeout);
    }
    motionHintTimeout = setTimeout(() => {
        if (!motionDetected) {
            updateMotionStatus('Motion not detected. On Android, allow motion sensors and open over HTTPS.');
        }
    }, 1200);
}

function handleOrientation(e) {
    if (!gameState.playing) return;
    motionDetected = true;
    updateMotionStatus('');
    const rawBeta = e.beta ?? 0;
    const rawGamma = e.gamma ?? 0;
    if (!calibration.ready) {
        calibration = { beta: rawBeta, gamma: rawGamma, ready: true };
    }

    const beta = rawBeta - calibration.beta;
    const gamma = rawGamma - calibration.gamma;
    const clampedGamma = Math.max(-45, Math.min(45, gamma));
    const clampedBeta = Math.max(-45, Math.min(45, beta));

    const orientation = screen.orientation?.angle ?? window.orientation ?? 0;
    if (orientation === 90) {
        tilt.x = clampedBeta / 45;
        tilt.y = -clampedGamma / 45;
    } else if (orientation === -90 || orientation === 270) {
        tilt.x = -clampedBeta / 45;
        tilt.y = clampedGamma / 45;
    } else if (orientation === 180) {
        tilt.x = -clampedGamma / 45;
        tilt.y = -clampedBeta / 45;
    } else {
        tilt.x = clampedGamma / 45;
        tilt.y = clampedBeta / 45;
    }
}

function updatePhysics() {
    if (!gameState.playing) return;
    
    let kx = 0, ky = 0;
    if (keys.left) kx -= 1;
    if (keys.right) kx += 1;
    if (keys.up) ky -= 1;
    if (keys.down) ky += 1;
    
    const inputX = kx !== 0 ? kx : tilt.x;
    const inputY = ky !== 0 ? ky : tilt.y;
    
    const gx = inputX * CONFIG.TILT_SENSITIVITY;
    const gy = inputY * CONFIG.TILT_SENSITIVITY;
    
    for (let step = 0; step < CONFIG.SUB_STEPS; step++) {
        balls.forEach(b => {
            if (b.locked) return;
            b.vx += gx / CONFIG.SUB_STEPS;
            b.vy += gy / CONFIG.SUB_STEPS;

            const speed = Math.hypot(b.vx, b.vy);
            if (speed > CONFIG.MAX_VELOCITY) {
                b.vx = (b.vx / speed) * CONFIG.MAX_VELOCITY;
                b.vy = (b.vy / speed) * CONFIG.MAX_VELOCITY;
            }

            b.vx *= CONFIG.FRICTION;
            b.vy *= CONFIG.FRICTION;

            if (speed < 0.03 && (Math.abs(inputX) + Math.abs(inputY)) > 0.02) {
                b.vx += gx * 0.75;
                b.vy += gy * 0.75;
            }

            b.x += b.vx / CONFIG.SUB_STEPS;
            b.y += b.vy / CONFIG.SUB_STEPS;
        });
        
        // Wall collisions
        balls.forEach(b => resolveWallCollisions(b));

        // Light assist near goal to avoid edge-sticking on the innermost ring
        balls.forEach(b => applyGoalAssist(b));
        
        // Ball-to-ball collisions
        resolveBallCollisions();
    }
    
    checkWin();
}

function resolveWallCollisions(b) {
    if (b.locked) return;
    const hw = CONFIG.WALL_WIDTH / 2;
    
    walls.forEach(w => {
        if (w.type === 'arc') {
            collideArc(b, w.radius, w.startAngle, w.endAngle, hw);
        } else if (w.type === 'radial') {
            collideRadial(b, w.angle, w.innerR, w.outerR, hw);
        } else if (w.type === 'boundary') {
            collideBoundary(b, w.radius, hw);
        }
    });
}

function collideArc(b, radius, startAngle, endAngle, hw) {
    const dx = b.x - centerX;
    const dy = b.y - centerY;
    const dist = Math.hypot(dx, dy);
    
    if (Math.abs(dist - radius) > hw + b.r + 5) return;
    
    let angle = Math.atan2(dy, dx);
    if (angle < 0) angle += PI2;
    
    if (!isAngleInRange(angle, startAngle, endAngle)) {
        checkEndpoint(b, radius, startAngle, hw);
        checkEndpoint(b, radius, endAngle, hw);
        return;
    }
    
    const inner = radius - hw;
    const outer = radius + hw;
    
    if (dist + b.r > inner && dist - b.r < outer) {
        const nx = dx / dist;
        const ny = dy / dist;
        
        if (dist < radius) {
            const target = inner - b.r - 1;
            if (dist > target) {
                b.x = centerX + nx * target;
                b.y = centerY + ny * target;
                const dot = b.vx * nx + b.vy * ny;
                if (dot > 0) { b.vx -= dot * nx; b.vy -= dot * ny; }
            }
        } else {
            const target = outer + b.r + 1;
            if (dist < target) {
                b.x = centerX + nx * target;
                b.y = centerY + ny * target;
                const dot = b.vx * nx + b.vy * ny;
                if (dot < 0) { b.vx -= dot * nx; b.vy -= dot * ny; }
            }
        }
    }
}

function checkEndpoint(b, radius, angle, hw) {
    const px = centerX + Math.cos(angle) * radius;
    const py = centerY + Math.sin(angle) * radius;
    const dx = b.x - px;
    const dy = b.y - py;
    const dist = Math.hypot(dx, dy);
    const minDist = b.r + hw;
    
    if (dist < minDist && dist > 0.1) {
        const nx = dx / dist;
        const ny = dy / dist;
        const push = minDist - dist + 1;
        b.x += nx * push;
        b.y += ny * push;
        const dot = b.vx * nx + b.vy * ny;
        if (dot < 0) { b.vx -= dot * nx * 0.9; b.vy -= dot * ny * 0.9; }
    }
}

function collideRadial(b, angle, innerR, outerR, hw) {
    const dx = b.x - centerX;
    const dy = b.y - centerY;
    const dist = Math.hypot(dx, dy);
    
    if (dist < innerR - b.r || dist > outerR + b.r) return;
    
    const wallDirX = Math.cos(angle);
    const wallDirY = Math.sin(angle);
    const wallNormX = -wallDirY;
    const wallNormY = wallDirX;
    
    const projDist = dx * wallDirX + dy * wallDirY;
    if (projDist < innerR - b.r || projDist > outerR + b.r) return;
    
    const perpDist = dx * wallNormX + dy * wallNormY;
    
    if (Math.abs(perpDist) < hw + b.r) {
        const sign = perpDist > 0 ? 1 : -1;
        const penetration = hw + b.r - Math.abs(perpDist);
        
        if (penetration > 0) {
            b.x += wallNormX * (penetration + 1) * sign;
            b.y += wallNormY * (penetration + 1) * sign;
            
            const dot = b.vx * wallNormX + b.vy * wallNormY;
            if (dot * sign < 0) {
                b.vx -= dot * wallNormX * 0.9;
                b.vy -= dot * wallNormY * 0.9;
            }
        }
    }
    
    checkRadialEndpoint(b, angle, innerR, hw);
    checkRadialEndpoint(b, angle, outerR, hw);
}

function checkRadialEndpoint(b, angle, r, hw) {
    const px = centerX + Math.cos(angle) * r;
    const py = centerY + Math.sin(angle) * r;
    const dx = b.x - px;
    const dy = b.y - py;
    const dist = Math.hypot(dx, dy);
    const minDist = b.r + hw;
    
    if (dist < minDist && dist > 0.1) {
        const nx = dx / dist;
        const ny = dy / dist;
        const push = minDist - dist + 1;
        b.x += nx * push;
        b.y += ny * push;
        const dot = b.vx * nx + b.vy * ny;
        if (dot < 0) { b.vx -= dot * nx * 0.9; b.vy -= dot * ny * 0.9; }
    }
}

function collideBoundary(b, radius, hw) {
    const dx = b.x - centerX;
    const dy = b.y - centerY;
    const dist = Math.hypot(dx, dy);
    const maxDist = radius - hw - b.r;
    
    if (dist > maxDist) {
        const nx = dx / dist;
        const ny = dy / dist;
        b.x = centerX + nx * (maxDist - 1);
        b.y = centerY + ny * (maxDist - 1);
        const dot = b.vx * nx + b.vy * ny;
        if (dot > 0) { b.vx -= dot * nx * 1.2; b.vy -= dot * ny * 1.2; }
    }
}

function applyGoalAssist(b) {
    if (b.locked) return;
    const dx = centerX - b.x;
    const dy = centerY - b.y;
    const d = Math.hypot(dx, dy);
    const assistStart = goalRadius + b.r * 2.2;
    if (d < assistStart && d > goalRadius * 0.55) {
        const nx = dx / d;
        const ny = dy / d;
        const strength = ((assistStart - d) / assistStart) * 0.09;
        b.vx += nx * strength;
        b.vy += ny * strength;
    }
}

function resolveBallCollisions() {
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            const b1 = balls[i];
            const b2 = balls[j];
            if (b1.locked && b2.locked) {
                continue;
            }
            
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const dist = Math.hypot(dx, dy);
            const minDist = b1.r + b2.r;
            
            if (dist < minDist && dist > 0.01) {
                const nx = dx / dist;
                const ny = dy / dist;
                const overlap = (minDist - dist) / 2 + 1;
                
                if (!b1.locked) {
                    b1.x -= nx * overlap;
                    b1.y -= ny * overlap;
                }
                if (!b2.locked) {
                    b2.x += nx * overlap;
                    b2.y += ny * overlap;
                }
                
                const dvx = b2.vx - b1.vx;
                const dvy = b2.vy - b1.vy;
                const dvn = dvx * nx + dvy * ny;
                
                if (dvn < 0) {
                    if (!b1.locked) {
                        b1.vx += dvn * nx * 0.5;
                        b1.vy += dvn * ny * 0.5;
                    }
                    if (!b2.locked) {
                        b2.vx -= dvn * nx * 0.5;
                        b2.vy -= dvn * ny * 0.5;
                    }
                }
            }
        }
    }
}

function isAngleInRange(angle, start, end) {
    const a = ((angle % PI2) + PI2) % PI2;
    const s = ((start % PI2) + PI2) % PI2;
    const e = ((end % PI2) + PI2) % PI2;
    
    if (s <= e) {
        return a >= s && a <= e;
    } else {
        return a >= s || a <= e;
    }
}

function checkWin() {
    let count = 0;
    balls.forEach(b => {
        const d = Math.hypot(b.x - centerX, b.y - centerY);
        if (d < goalRadius * 0.86) {
            count++;
            b.inGoal = true;
            if (lockGoalEnabled && !b.locked && d < goalRadius * 0.65) {
                b.locked = true;
                b.vx = 0;
                b.vy = 0;
                b.x = centerX;
                b.y = centerY;
            } else if (!b.locked && lockGoalEnabled) {
                b.vx *= 0.6;
                b.vy *= 0.6;
            }
        } else {
            b.inGoal = false;
            b.locked = false;
        }

        if (!lockGoalEnabled) {
            b.locked = false;
        }
    });
    
    const elapsed = Date.now() - gameState.startTime;
    gameState.timeStr = formatTime(elapsed);
    document.getElementById('timerBadge').innerText = `${gameState.timeStr} | ${count}/${CONFIG.BALL_COUNT} ⚪`;
    
    if (count === CONFIG.BALL_COUNT && !gameState.won) {
        gameState.won = true;
        gameState.playing = false;
        document.getElementById('finalTime').innerText = gameState.timeStr;
        setTimeout(() => document.getElementById('winScreen').classList.remove('hidden'), 400);
    }
}

function loop() {
    updatePhysics();
    render();
    requestAnimationFrame(loop);
}

function render() {
    // Wood background
    const bgGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius * 1.1);
    bgGrad.addColorStop(0, '#f0e0c8');
    bgGrad.addColorStop(0.6, '#dcc8a8');
    bgGrad.addColorStop(1, '#c8b090');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, width, height);
    
    // Wood grain
    ctx.strokeStyle = 'rgba(139, 90, 43, 0.05)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 40; i++) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8 + i * 12, 0, PI2);
        ctx.stroke();
    }
    
    // Goal hole
    ctx.beginPath();
    ctx.arc(centerX, centerY, goalRadius, 0, PI2);
    const goalGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, goalRadius);
    goalGrad.addColorStop(0, '#0d2d0d');
    goalGrad.addColorStop(0.6, '#1a4a1a');
    goalGrad.addColorStop(1, '#0f3a0f');
    ctx.fillStyle = goalGrad;
    ctx.fill();
    ctx.strokeStyle = '#082008';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Walls
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    walls.forEach(w => {
        if (w.type === 'arc') {
            ctx.beginPath();
            ctx.arc(centerX, centerY, w.radius, w.startAngle, w.endAngle);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = CONFIG.WALL_WIDTH + 4;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, w.radius, w.startAngle, w.endAngle);
            ctx.strokeStyle = '#6d4c41';
            ctx.lineWidth = CONFIG.WALL_WIDTH;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(centerX, centerY, w.radius, w.startAngle, w.endAngle);
            ctx.strokeStyle = '#9d7c61';
            ctx.lineWidth = CONFIG.WALL_WIDTH - 2;
            ctx.stroke();
            
        } else if (w.type === 'radial') {
            const x1 = centerX + Math.cos(w.angle) * w.innerR;
            const y1 = centerY + Math.sin(w.angle) * w.innerR;
            const x2 = centerX + Math.cos(w.angle) * w.outerR;
            const y2 = centerY + Math.sin(w.angle) * w.outerR;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = CONFIG.WALL_WIDTH + 4;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = '#6d4c41';
            ctx.lineWidth = CONFIG.WALL_WIDTH;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = '#9d7c61';
            ctx.lineWidth = CONFIG.WALL_WIDTH - 2;
            ctx.stroke();
            
        } else if (w.type === 'boundary') {
            ctx.beginPath();
            ctx.arc(centerX, centerY, w.radius, 0, PI2);
            ctx.strokeStyle = '#4e342e';
            ctx.lineWidth = CONFIG.WALL_WIDTH * 2;
            ctx.stroke();
            ctx.strokeStyle = '#6d4c41';
            ctx.lineWidth = CONFIG.WALL_WIDTH * 2 - 4;
            ctx.stroke();
        }
    });
    
    // Balls
    balls.forEach(b => {
        // Shadow
        ctx.beginPath();
        ctx.arc(b.x + 2, b.y + 3, b.r, 0, PI2);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fill();
        
        // Ball
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, PI2);
        const ballGrad = ctx.createRadialGradient(
            b.x - b.r * 0.3, b.y - b.r * 0.3, 0,
            b.x, b.y, b.r
        );
        ballGrad.addColorStop(0, '#ffffff');
        ballGrad.addColorStop(0.15, '#f8f8f8');
        ballGrad.addColorStop(0.5, '#b8c8d8');
        ballGrad.addColorStop(1, b.inGoal ? '#4a7a4a' : '#607080');
        ctx.fillStyle = ballGrad;
        ctx.fill();
        
        // Shine
        ctx.beginPath();
        ctx.arc(b.x - b.r * 0.35, b.y - b.r * 0.35, b.r * 0.22, 0, PI2);
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fill();
    });
}

function formatTime(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    return `${m.toString().padStart(2, '0')}:${(s % 60).toString().padStart(2, '0')}`;
}

function requestPermissions() {
    if (!window.isSecureContext) {
        updateMotionStatus('Motion sensors require HTTPS on Android. Use https:// or localhost.');
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
            .then(state => { if (state === 'granted') startGame(); else startGame(); })
            .catch(() => startGame());
    } else {
        startGame();
    }
}

function updateMotionStatus(message) {
    const statusEl = document.getElementById('motionStatus');
    if (statusEl) {
        statusEl.textContent = message;
    }
}

init();
</script>
</body>
</html>
