<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Wood Labyrinth</title>
    <style>
        :root {
            --wood-dark: #3e2723;
            --wood-light: #8d6e63;
            --felt-green: #2e7d32;
            --steel: #b0bec5;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1005;
            font-family: 'Helvetica Neue', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            /* Box shadow for board depth */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        /* UI OVERLAYS */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(20, 10, 5, 0.92);
            color: #e3c099;
            z-index: 20;
            transition: opacity 0.4s ease;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #d4a76a;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        p {
            font-size: 1rem;
            color: #a1887f;
            margin-bottom: 2rem;
            max-width: 80%;
            text-align: center;
            line-height: 1.5;
        }

        button {
            padding: 16px 48px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(to bottom, #d4a76a, #a67c52);
            color: #2b1d0e;
            border: 1px solid #754c24;
            border-radius: 30px;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 6px 0 #5d4037, 0 15px 20px rgba(0,0,0,0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #5d4037, 0 5px 10px rgba(0,0,0,0.4);
        }

        #hud {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #timerBadge {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: 20px;
            color: #fff;
            font-weight: 700;
            font-size: 1.2rem;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .hidden { 
            opacity: 0; 
            pointer-events: none; 
        }
    </style>
</head>
<body>

    <div id="hud"><span id="timerBadge">00:00</span></div>

    <div id="startScreen" class="overlay">
        <h1>Labyrinth</h1>
        <p>Hold your device flat.<br>Tilt gently to guide 4 steel balls to the center.</p>
        <button id="btnStart">Unlock & Play</button>
    </div>

    <div id="winScreen" class="overlay hidden">
        <h1 style="color:#81c784">Success</h1>
        <p>All balls secured in <span id="finalTime" style="color:white; font-weight:bold;"></span></p>
        <button id="btnRestart">Play Again</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * --- PHYSICS CONFIGURATION ---
 * Adjust these to tune the "Feel" of the game
 */
const CONFIG = {
    RINGS: 7,               // Number of concentric walls
    BALL_COUNT: 4,          
    WALL_WIDTH: 14,         // Thickness of walls (pixels)
    BALL_RADIUS: 8,         // Radius of ball (pixels)
    FRICTION: 0.96,         // Air resistance (Lower = slide more)
    ELASTICITY: 0.4,        // Bounciness (0 = no bounce, 1 = super ball)
    TILT_SENSITIVITY: 0.04, // How much tilt affects force
    SUB_STEPS: 8,           // Physics steps per frame (Higher = Anti-tunneling)
    INPUT_SMOOTHING: 0.15   // Low pass filter for accelerometer (0.1 = very smooth/laggy, 1.0 = raw)
};

// --- SYSTEM GLOBALS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize rendering
let width, height, centerX, centerY, maxRadius;

let gameState = {
    playing: false,
    won: false,
    startTime: 0,
    timeStr: "00:00"
};

// Physics Inputs
let input = { x: 0, y: 0 }; // Smoothed input
let targetInput = { x: 0, y: 0 }; // Raw input

// Entities
let balls = [];
let walls = [];

/**
 * --- MATH HELPERS ---
 */
const PI2 = Math.PI * 2;

function distSq(x1, y1, x2, y2) { return (x1-x2)**2 + (y1-y2)**2; }
function normalizeAngle(a) { 
    a = a % PI2;
    return a < 0 ? a + PI2 : a;
}

/**
 * --- INITIALIZATION & MAZE GENERATION ---
 */
function init() {
    resize();
    window.addEventListener('resize', resize);
    
    // Controls
    document.getElementById('btnStart').addEventListener('click', requestPermissions);
    document.getElementById('btnRestart').addEventListener('click', startGame);

    // Orientation
    window.addEventListener('deviceorientation', handleOrientation);

    // Start Loop
    requestAnimationFrame(loop);
}

function resize() {
    width = Math.min(window.innerWidth, 800); // Max width constraint
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    centerX = width / 2;
    centerY = height / 2;
    maxRadius = Math.min(width, height) * 0.45;
}

function generateLevel() {
    walls = [];
    const step = maxRadius / (CONFIG.RINGS + 1);

    // Generate Concentric Rings with Openings
    for (let i = 1; i <= CONFIG.RINGS; i++) {
        const r = i * step;
        
        // Random Gap
        // Gap size gets slightly larger as we go out
        const gapSizeDeg = 45 + (Math.random() * 30); 
        const gapSizeRad = (gapSizeDeg * Math.PI) / 180;
        const gapAngle = Math.random() * PI2;

        // We define a wall as an ARC that goes from A to B.
        // To make a ring with a gap, the wall goes from (GapEnd) around to (GapStart)
        const start = gapAngle + gapSizeRad/2;
        const end = gapAngle + PI2 - gapSizeRad/2;

        walls.push({
            type: 'arc',
            radius: r,
            startAngle: start, // Normalized in physics loop
            endAngle: end,
            width: CONFIG.WALL_WIDTH
        });
    }

    // Outer Boundary Ring (Solid)
    walls.push({
        type: 'arc',
        radius: maxRadius,
        startAngle: 0,
        endAngle: PI2 + 0.1, // Full circle
        width: CONFIG.WALL_WIDTH * 2 // Thicker boundary
    });
}

function spawnBalls() {
    balls = [];
    // Spawn balls in the outermost channel, spread out
    const spawnR = maxRadius * 0.85;
    for(let i=0; i<CONFIG.BALL_COUNT; i++) {
        const angle = (i / CONFIG.BALL_COUNT) * PI2 + 0.5; // Offset slightly
        balls.push({
            x: centerX + Math.cos(angle) * spawnR,
            y: centerY + Math.sin(angle) * spawnR,
            vx: 0, vy: 0,
            radius: CONFIG.BALL_RADIUS
        });
    }
}

function startGame() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('winScreen').classList.add('hidden');
    
    resize();
    generateLevel();
    spawnBalls();
    
    gameState.playing = true;
    gameState.won = false;
    gameState.startTime = Date.now();
    
    // Reset inputs
    input = {x:0, y:0};
    targetInput = {x:0, y:0};
}

/**
 * --- PHYSICS ENGINE (SUB-STEPPED) ---
 */
function handleOrientation(e) {
    if(!gameState.playing) return;
    
    // Gamma: Left/Right (-90 to 90)
    // Beta: Front/Back (-180 to 180)
    
    // Clamp values to avoid extreme flips
    const x = Math.min(Math.max(e.gamma, -45), 45); 
    const y = Math.min(Math.max(e.beta, -45), 45);
    
    targetInput.x = x;
    targetInput.y = y;
}

function updatePhysics() {
    if(!gameState.playing) return;

    // 1. Smooth Input (Low Pass Filter)
    input.x += (targetInput.x - input.x) * CONFIG.INPUT_SMOOTHING;
    input.y += (targetInput.y - input.y) * CONFIG.INPUT_SMOOTHING;

    // Calculate Gravity Force based on tilt
    const gx = input.x * CONFIG.TILT_SENSITIVITY;
    const gy = input.y * CONFIG.TILT_SENSITIVITY;

    // 2. Sub-Stepping Loop
    // This runs physics N times per frame to catch collisions at high speeds
    for(let step=0; step<CONFIG.SUB_STEPS; step++) {
        
        balls.forEach(b => {
            // Apply Forces
            b.vx += gx;
            b.vy += gy;
            
            // Friction
            b.vx *= CONFIG.FRICTION;
            b.vy *= CONFIG.FRICTION;

            // Tentative Movement
            b.x += b.vx;
            b.y += b.vy;

            // Solve Constraints
            solveCollisions(b);
        });
    }

    // 3. Win Condition Check
    checkWin();
}

function solveCollisions(b) {
    // We only resolve Wall collisions here. 
    // Ball-to-Ball collision is omitted to keep game "clean" and focused on maze solving.

    walls.forEach(w => {
        // Distance from center
        const dx = b.x - centerX;
        const dy = b.y - centerY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // 1. Broad Phase: Is ball close to the Ring's radius?
        const halfWall = w.width / 2;
        const ballR = b.radius;
        
        if (dist >= w.radius - halfWall - ballR && dist <= w.radius + halfWall + ballR) {
            
            // 2. Narrow Phase: Angle Check
            let angle = Math.atan2(dy, dx);
            if (angle < 0) angle += PI2; // Normalize 0 to 2PI

            // Check if this angle is within the wall's arc
            // We need to handle the wrapping case (e.g. wall goes from 350deg to 10deg)
            let inWall = false;
            
            // Normalize wall start/end to 0-2PI
            const start = normalizeAngle(w.startAngle);
            const end = normalizeAngle(w.endAngle);

            if (start < end) {
                // Normal case
                if (angle >= start && angle <= end) inWall = true;
            } else {
                // Wrapping case
                if (angle >= start || angle <= end) inWall = true;
            }

            if (inWall) {
                // COLLISION WITH FACE OF WALL
                // Push ball out along the Normal (Radial Vector)
                // Determine which side of the wall is closer
                const distToInner = Math.abs(dist - (w.radius - halfWall));
                const distToOuter = Math.abs(dist - (w.radius + halfWall));
                
                // Normal vector (normalized)
                const nx = dx / dist;
                const ny = dy / dist;

                if (dist < w.radius) {
                    // Inside the ring, push inwards towards center
                    // Wait, if dist < radius, we are on the inner side. Push IN? 
                    // No, push OUT of the wall geometry.
                    // If ball is at radius 90, and wall inner edge is 95. Push to 90.
                    
                    const pen = (w.radius - halfWall - ballR) - dist;
                    // Actually simpler: Push towards center if closer to inner, away if closer to outer?
                    // No, just push away from the wall core.
                    
                    // If dist < w.radius, we are "inside" the ring physically.
                    // Push vector is -Normal.
                    const overlap = (ballR + halfWall) - Math.abs(dist - w.radius);
                    
                    // Direction: Are we closer to inner or outer edge?
                    if (dist < w.radius) {
                        // Push Inwards (decrease radius)
                        b.x -= nx * overlap;
                        b.y -= ny * overlap;
                        reflect(b, nx, ny);
                    } else {
                        // Push Outwards (increase radius)
                        b.x += nx * overlap;
                        b.y += ny * overlap;
                        reflect(b, -nx, -ny);
                    }
                }
            } else {
                // COLLISION WITH END CAPS (The "Tips" of the wall at the gap)
                // We check collision against two circles placed at start and end of arc
                checkCapCollision(b, w.radius, w.startAngle);
                checkCapCollision(b, w.radius, w.endAngle);
            }
        }
    });
}

function checkCapCollision(b, r, angle) {
    // Calculate position of the wall tip
    const capX = centerX + Math.cos(angle) * r;
    const capY = centerY + Math.sin(angle) * r;
    
    // Determine distance from ball to Tip
    const distSq = (b.x - capX)**2 + (b.y - capY)**2;
    const minDist = CONFIG.WALL_WIDTH/2 + b.radius;
    
    if (distSq < minDist**2) {
        const dist = Math.sqrt(distSq);
        // Normal vector from Cap to Ball
        const nx = (b.x - capX) / dist;
        const ny = (b.y - capY) / dist;
        
        const overlap = minDist - dist;
        
        // Push ball away
        b.x += nx * overlap;
        b.y += ny * overlap;
        
        reflect(b, nx, ny);
    }
}

function reflect(b, nx, ny) {
    // Reflect velocity vector V around Normal N
    // V_new = V - 2(V dot N)N
    const dot = b.vx * nx + b.vy * ny;
    
    // Only bounce if moving INTO the wall
    if (dot < 0) {
        b.vx = (b.vx - 2 * dot * nx) * CONFIG.ELASTICITY;
        b.vy = (b.vy - 2 * dot * ny) * CONFIG.ELASTICITY;
    }
}

function checkWin() {
    // Goal Zone
    const goalR = maxRadius / (CONFIG.RINGS + 2);
    let count = 0;
    
    balls.forEach(b => {
        const d = Math.sqrt((b.x - centerX)**2 + (b.y - centerY)**2);
        if(d < goalR) count++;
    });
    
    if(count === CONFIG.BALL_COUNT && !gameState.won) {
        gameState.won = true;
        gameState.playing = false;
        
        const elapsed = Date.now() - gameState.startTime;
        const finalStr = formatTime(elapsed);
        document.getElementById('finalTime').innerText = finalStr;
        document.getElementById('winScreen').classList.remove('hidden');
    }
}

/**
 * --- RENDERING ---
 */
function loop() {
    // 1. Logic
    updatePhysics();
    updateTimer();

    // 2. Render
    ctx.clearRect(0,0,width,height);
    
    drawBoard();
    drawMaze();
    drawBalls();

    requestAnimationFrame(loop);
}

function drawBoard() {
    // Wood Texture Background
    const grad = ctx.createRadialGradient(centerX, centerY, 10, centerX, centerY, maxRadius*1.2);
    grad.addColorStop(0, '#eecfa1');
    grad.addColorStop(1, '#8d6e63');
    
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,width,height);
    
    // Goal Hole
    ctx.beginPath();
    ctx.arc(centerX, centerY, maxRadius / (CONFIG.RINGS + 2), 0, PI2);
    ctx.fillStyle = '#1b5e20';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Inner Shadow of hole
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'black';
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function drawMaze() {
    // Walls
    ctx.lineCap = 'round'; // Rounds the ends of the walls visually
    
    // Drop Shadow for Walls (creates depth)
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 4;

    walls.forEach(w => {
        ctx.beginPath();
        ctx.arc(centerX, centerY, w.radius, w.startAngle, w.endAngle);
        ctx.lineWidth = w.width;
        ctx.strokeStyle = '#4e342e';
        ctx.stroke();
        
        // Inner highlight for 3D effect on wall top
        ctx.beginPath();
        ctx.arc(centerX, centerY, w.radius, w.startAngle, w.endAngle);
        ctx.lineWidth = w.width - 4;
        ctx.strokeStyle = '#6d4c41';
        ctx.stroke();
    });

    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
}

function drawBalls() {
    balls.forEach(b => {
        // Drop Shadow
        ctx.beginPath();
        ctx.arc(b.x + 2, b.y + 4, b.radius, 0, PI2);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fill();

        // Ball Body
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, PI2);
        
        // Metallic Gradient
        const grad = ctx.createRadialGradient(
            b.x - b.radius*0.3, b.y - b.radius*0.3, b.radius*0.1, 
            b.x, b.y, b.radius
        );
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.4, '#cfd8dc');
        grad.addColorStop(1, '#546e7a');
        
        ctx.fillStyle = grad;
        ctx.fill();
        
        // Shine
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(b.x - b.radius*0.3, b.y - b.radius*0.3, 2, 0, PI2);
        ctx.fill();
    });
}

function updateTimer() {
    if(!gameState.playing) return;
    const elapsed = Date.now() - gameState.startTime;
    document.getElementById('timerBadge').innerText = formatTime(elapsed);
}

function formatTime(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const remS = s % 60;
    return `${m < 10 ? '0'+m : m}:${remS < 10 ? '0'+remS : remS}`;
}

/**
 * --- IOS PERMISSIONS ---
 */
function requestPermissions() {
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
            .then(state => {
                if (state === 'granted') startGame();
                else alert('Tilt controls are required to play.');
            })
            .catch(console.error);
    } else {
        startGame();
    }
}

// Boot
init();
</script>
</body>
</html>