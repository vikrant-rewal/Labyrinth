<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro Wood Labyrinth</title>
    <style>
        :root {
            --wood-dark: #3e2723;
            --wood-light: #8d6e63;
            --felt-green: #2e7d32;
            --steel: #b0bec5;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1005;
            font-family: 'Helvetica Neue', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            /* Box shadow for board depth */
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
        }

        /* UI OVERLAYS */
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(20, 10, 5, 0.92);
            color: #e3c099;
            z-index: 20;
            transition: opacity 0.4s ease;
            backdrop-filter: blur(5px);
        }

        h1 {
            font-size: 2.5rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: #d4a76a;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }

        p {
            font-size: 1rem;
            color: #a1887f;
            margin-bottom: 2rem;
            max-width: 80%;
            text-align: center;
            line-height: 1.5;
        }

        button {
            padding: 16px 48px;
            font-size: 1.1rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            background: linear-gradient(to bottom, #d4a76a, #a67c52);
            color: #2b1d0e;
            border: 1px solid #754c24;
            border-radius: 30px;
            font-weight: 800;
            cursor: pointer;
            box-shadow: 0 6px 0 #5d4037, 0 15px 20px rgba(0,0,0,0.4);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        button:active {
            transform: translateY(4px);
            box-shadow: 0 2px 0 #5d4037, 0 5px 10px rgba(0,0,0,0.4);
        }

        #hud {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #timerBadge {
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 16px;
            border-radius: 20px;
            color: #fff;
            font-weight: 700;
            font-size: 1.2rem;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .hidden { 
            opacity: 0; 
            pointer-events: none; 
        }
    </style>
</head>
<body>

    <div id="hud"><span id="timerBadge">00:00</span></div>

    <div id="startScreen" class="overlay">
        <h1>Labyrinth</h1>
        <p>Hold your device flat.<br>Tilt gently to guide 4 steel balls to the center.</p>
        <button id="btnStart">Unlock & Play</button>
    </div>

    <div id="winScreen" class="overlay hidden">
        <h1 style="color:#81c784">All Balls Secured!</h1>
        <p>Completed in <span id="finalTime" style="color:white; font-weight:bold;"></span></p>
        <button id="btnRestart">Play Again</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * --- PHYSICS CONFIGURATION ---
 * Tuned for smooth mobile gameplay without jitter or tunneling
 */
const CONFIG = {
    RINGS: 7,               // Number of concentric walls
    BALL_COUNT: 4,          
    WALL_WIDTH: 14,         // Thickness of walls (pixels)
    BALL_RADIUS: 8,         // Radius of ball (pixels)
    FRICTION: 0.92,         // Velocity damping per frame (higher friction = less slide, smoother)
    ELASTICITY: 0.05,       // Bounciness on wall hit (very low to prevent jitter)
    TILT_SENSITIVITY: 0.015, // Very low sensitivity to avoid overshooting
    SUB_STEPS: 8,           // Physics steps per frame for collision detection (more accurate)
    INPUT_SMOOTHING: 0.7,   // Accelerometer smoothing (higher = less jittery)
    MAX_VELOCITY: 3.5,      // Cap velocity to prevent overshoots
    POSITIONAL_CORRECTION: 0.9 // How aggressively to correct penetrations
};

// --- SYSTEM GLOBALS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false }); // Optimize rendering
let width, height, centerX, centerY, maxRadius;

let gameState = {
    playing: false,
    won: false,
    startTime: 0,
    timeStr: "00:00"
};

// Physics Inputs
let input = { x: 0, y: 0 }; // Smoothed input
let targetInput = { x: 0, y: 0 }; // Raw input

// Entities
let balls = [];
let walls = [];

/**
 * --- MATH HELPERS ---
 */
const PI2 = Math.PI * 2;

function distSq(x1, y1, x2, y2) { return (x1-x2)**2 + (y1-y2)**2; }
function normalizeAngle(a) { 
    a = a % PI2;
    return a < 0 ? a + PI2 : a;
}

/**
 * --- INITIALIZATION & MAZE GENERATION ---
 */
function init() {
    resize();
    window.addEventListener('resize', resize);
    
    // Controls
    document.getElementById('btnStart').addEventListener('click', requestPermissions);
    document.getElementById('btnRestart').addEventListener('click', startGame);

    // Orientation
    window.addEventListener('deviceorientation', handleOrientation);

    // Start Loop
    requestAnimationFrame(loop);
}

function resize() {
    width = Math.min(window.innerWidth, 800); // Max width constraint
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    centerX = width / 2;
    centerY = height / 2;
    maxRadius = Math.min(width, height) * 0.45;
}

function generateLevel() {
    walls = [];
    const step = maxRadius / (CONFIG.RINGS + 1);

    // Create a randomized maze pattern for variety
    const gapPattern = [];
    
    // Generate ring gaps with random rotation and size variation
    // This makes each game different
    const spiralTwists = Math.random() * 3 + 1; // Random number of rotations (1-4)
    const startingGapAngle = Math.random() * PI2; // Random starting position
    
    for (let i = 0; i < CONFIG.RINGS; i++) {
        // Random rotation each ring for variety
        const baseAngle = (i / CONFIG.RINGS) * PI2;
        const rotationFactor = (i / CONFIG.RINGS) * PI2 * spiralTwists; // Variable rotations
        const randomOffset = (Math.random() - 0.5) * 0.4; // Random jitter
        const gapAngle = startingGapAngle + baseAngle + rotationFactor + randomOffset;
        
        // Variable gap sizes for variety (but still navigable)
        // Larger gaps for inner rings (easier to enter center), smaller for outer rings (more challenge)
        const ringProgress = i / CONFIG.RINGS; // 0 for outer, 1 for inner
        const baseSizeDeg = 50 + ringProgress * 30; // 50-80 degrees (50 outer, 80 inner)
        const gapSizeDeg = baseSizeDeg + (Math.random() - 0.5) * 15; // Add some variance
        const gapSizeRad = (gapSizeDeg * Math.PI) / 180;
        
        gapPattern.push({
            ringIndex: i + 1,
            gapAngle: gapAngle,
            gapSize: gapSizeRad
        });
    }

    // 1. CONCENTRIC RINGS (with randomized gaps)
    for (let i = 1; i <= CONFIG.RINGS; i++) {
        const r = i * step;
        const gapInfo = gapPattern[i - 1];
        
        const gapAngle = gapInfo.gapAngle;
        const gapSize = gapInfo.gapSize;

        // Arc wall: from gap-end around to gap-start
        const start = gapAngle + gapSize / 2;
        const end = gapAngle + PI2 - gapSize / 2;

        walls.push({
            type: 'arc',
            radius: r,
            startAngle: start,
            endAngle: end,
            width: CONFIG.WALL_WIDTH
        });
    }

    // 2. RADIAL BLOCKING WALLS (Dead ends between rings)
    // Randomized for variety
    for (let i = 1; i < CONFIG.RINGS; i++) {
        const innerR = i * step;
        const outerR = (i + 1) * step;

        // Random number of barriers (2-4 per ring)
        const barrierCount = 2 + Math.floor(Math.random() * 3);
        
        for (let b = 0; b < barrierCount; b++) {
            // Randomize barrier positions to avoid repeating patterns
            const randomAngle = Math.random() * PI2;
            // Position away from current ring's gap
            const distFromGap = Math.abs(randomAngle - gapPattern[i-1].gapAngle);
            
            // Only place barrier if it's far enough from the gap
            if (distFromGap > gapPattern[i-1].gapSize * 1.5) {
                walls.push({
                    type: 'radial',
                    angle: randomAngle,
                    innerR: innerR,
                    outerR: outerR,
                    width: CONFIG.WALL_WIDTH
                });
            }
        }
    }

    // 3. OUTER BOUNDARY RING (Solid)
    walls.push({
        type: 'arc',
        radius: maxRadius,
        startAngle: 0,
        endAngle: PI2 + 0.1, // Full circle
        width: CONFIG.WALL_WIDTH * 2 // Thicker boundary
    });
}

function spawnBalls() {
    balls = [];
    // Spawn balls in the outermost channel, spread out
    const spawnR = maxRadius * 0.85;
    for(let i=0; i<CONFIG.BALL_COUNT; i++) {
        const angle = (i / CONFIG.BALL_COUNT) * PI2 + 0.5; // Offset slightly
        balls.push({
            x: centerX + Math.cos(angle) * spawnR,
            y: centerY + Math.sin(angle) * spawnR,
            vx: 0, vy: 0,
            radius: CONFIG.BALL_RADIUS
        });
    }
}

function startGame() {
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('winScreen').classList.add('hidden');
    
    resize();
    generateLevel();
    spawnBalls();
    
    gameState.playing = true;
    gameState.won = false;
    gameState.startTime = Date.now();
    
    // Reset inputs
    input = {x:0, y:0};
    targetInput = {x:0, y:0};
}

/**
 * --- PHYSICS ENGINE (SUB-STEPPED) ---
 */
function handleOrientation(e) {
    if(!gameState.playing) return;
    
    // Gamma: Left/Right (-90 to 90)
    // Beta: Front/Back (-180 to 180)
    
    // Clamp values to avoid extreme flips
    const x = Math.min(Math.max(e.gamma, -45), 45); 
    const y = Math.min(Math.max(e.beta, -45), 45);
    
    targetInput.x = x;
    targetInput.y = y;
}

function updatePhysics() {
    if(!gameState.playing) return;

    // 1. Smooth Accelerometer Input (Low Pass Filter)
    // Higher value = more responsive but jerkier
    input.x += (targetInput.x - input.x) * CONFIG.INPUT_SMOOTHING;
    input.y += (targetInput.y - input.y) * CONFIG.INPUT_SMOOTHING;

    // Calculate gravity force based on tilt
    // Very low sensitivity to prevent aggressive movement
    const gx = input.x * CONFIG.TILT_SENSITIVITY;
    const gy = input.y * CONFIG.TILT_SENSITIVITY;

    // 2. Sub-Stepping Physics Loop
    // Runs physics multiple times per frame for better collision detection
    const dtSubstep = 1 / (60 * CONFIG.SUB_STEPS);
    
    for(let step = 0; step < CONFIG.SUB_STEPS; step++) {
        balls.forEach(b => {
            // 2a. Apply Forces
            b.vx += gx * 0.5; // Scaled down further
            b.vy += gy * 0.5;
            
            // 2b. Clamp Velocity (prevent overshooting)
            const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
            if (speed > CONFIG.MAX_VELOCITY) {
                const scale = CONFIG.MAX_VELOCITY / speed;
                b.vx *= scale;
                b.vy *= scale;
            }
            
            // 2c. Friction/Damping
            b.vx *= CONFIG.FRICTION;
            b.vy *= CONFIG.FRICTION;

            // 2d. Position Update
            b.x += b.vx;
            b.y += b.vy;

            // 2e. Solve Collisions & Constraints
            solveCollisions(b);
        });

        // 2f. Ball-to-Ball Collisions (prevents overlapping and stacking)
        for (let i = 0; i < balls.length; i++) {
            for (let j = i + 1; j < balls.length; j++) {
                solveBallCollision(balls[i], balls[j]);
            }
        }
    }

    // 3. Win Condition Check
    checkWin();
}

function solveCollisions(b) {
    /**
     * IMPROVED COLLISION DETECTION & RESPONSE
     * Uses proper geometric tests to prevent penetration
     * Handles both arc and radial walls
     */
    const halfWall = CONFIG.WALL_WIDTH / 2;
    const ballR = b.radius;

    // 1. BOUNDARY ENFORCEMENT - Keep balls from leaving the board (works in any orientation)
    const dx = b.x - centerX;
    const dy = b.y - centerY;
    const distFromCenter = Math.sqrt(dx * dx + dy * dy);
    const boundaryRadius = maxRadius * 0.92;
    
    if (distFromCenter > boundaryRadius - ballR) {
        // Push ball back inside more aggressively - prevents escape when vertical
        const angle = Math.atan2(dy, dx);
        const correctedDist = boundaryRadius - ballR - 2; // Extra safety margin
        b.x = centerX + Math.cos(angle) * correctedDist;
        b.y = centerY + Math.sin(angle) * correctedDist;
        
        // Kill outward velocity completely
        const nx = Math.cos(angle);
        const ny = Math.sin(angle);
        const velDot = b.vx * nx + b.vy * ny;
        if (velDot > 0) {
            // Remove ALL outward velocity (not partial)
            b.vx -= velDot * nx * 1.3;
            b.vy -= velDot * ny * 1.3;
        }
    }

    // 2. COLLISION WITH WALLS
    walls.forEach(w => {
        if (w.type === 'arc') {
            collideWithArcWall(b, w, halfWall);
        } else if (w.type === 'radial') {
            collideWithRadialWall(b, w, halfWall);
        }
    });
}

function collideWithArcWall(b, w, halfWall) {
    /**
     * Collision detection for concentric ring walls
     */
    const ballR = b.radius;
    
    // Get vector from center to ball
    const dx = b.x - centerX;
    const dy = b.y - centerY;
    const distSq = dx * dx + dy * dy;
    const dist = Math.sqrt(distSq);
    
    // Skip if too far away
    const maxCheck = w.radius + halfWall + ballR + 20;
    if (dist > maxCheck) return;

    // Check if ball is in the wall's radial zone
    const inner = w.radius - halfWall;
    const outer = w.radius + halfWall;
    
    if (dist < inner - ballR || dist > outer + ballR) {
        return; // Too far in any direction
    }

    // Get ball's angle
    let ballAngle = Math.atan2(dy, dx);
    if (ballAngle < 0) ballAngle += PI2;

    // Check if angle is within the wall's angular range
    const angleInWall = isAngleBetween(ballAngle, w.startAngle, w.endAngle);

    if (angleInWall) {
        // Ball is within the angular range of the wall
        const penetration = calculateRadialPenetration(dist, inner, outer, ballR);
        
        if (penetration > 0) {
            // COLLISION! Push ball out
            const nx = dx / dist;
            const ny = dy / dist;
            const correctionDir = dist < w.radius ? -1 : 1;
            const correction = penetration * CONFIG.POSITIONAL_CORRECTION;
            
            b.x += nx * correction * correctionDir;
            b.y += ny * correction * correctionDir;

            // Dampen velocity with very low bounce to reduce jitter
            const velocityDot = b.vx * nx + b.vy * ny;
            if ((velocityDot > 0 && correctionDir > 0) || (velocityDot < 0 && correctionDir < 0)) {
                const bounce = 1 - CONFIG.ELASTICITY;
                b.vx -= velocityDot * nx * bounce * 0.85; // Extra damping factor
                b.vy -= velocityDot * ny * bounce * 0.85;
            }
        }
    } else {
        // Check collision with wall end caps
        checkCapCollision(b, w.radius, w.startAngle);
        checkCapCollision(b, w.radius, w.endAngle);
    }
}

function collideWithRadialWall(b, w, halfWall) {
    /**
     * Collision detection for radial blocking walls (dead ends)
     */
    const ballR = b.radius;
    
    // Radial wall is a line from angle w.angle, from innerR to outerR
    const wallAngle = w.angle;
    const wallX = Math.cos(wallAngle);
    const wallY = Math.sin(wallAngle);
    
    // Normal to wall (perpendicular)
    const nx = -wallY;
    const ny = wallX;
    
    // Vector from wall origin to ball
    const dx = b.x - centerX;
    const dy = b.y - centerY;
    
    // Distance from ball to the infinite line defined by wall angle
    const distToLine = Math.abs(dx * nx + dy * ny);
    
    // Only check if ball is close to the wall
    if (distToLine > ballR + halfWall) return;
    
    // Check if ball is within the radial extent of the wall
    const radialDist = dx * wallX + dy * wallY;
    
    if (radialDist < w.innerR - ballR || radialDist > w.outerR + ballR) {
        return; // Outside radial bounds
    }
    
    // Ball is hitting the wall
    // Determine which side of the wall
    const sideSign = (dx * nx + dy * ny) > 0 ? 1 : -1;
    const penetration = ballR + halfWall - distToLine;
    
    if (penetration > 0) {
        // Push ball away from wall
        const pushX = nx * penetration * CONFIG.POSITIONAL_CORRECTION * sideSign;
        const pushY = ny * penetration * CONFIG.POSITIONAL_CORRECTION * sideSign;
        
        b.x += pushX;
        b.y += pushY;
        
        // Dampen velocity in the direction of the wall normal
        const velDot = b.vx * nx + b.vy * ny;
        if (velDot * sideSign < 0) {
            // Moving into wall - use stronger damping to reduce bounce and jitter
            const bounce = 1 - CONFIG.ELASTICITY;
            b.vx -= velDot * nx * bounce * 0.85; // Extra damping factor
            b.vy -= velDot * ny * bounce * 0.85;
        }
    }
}

function solveBallCollision(b1, b2) {
    /**
     * Handle ball-to-ball collision
     * Prevents overlapping and keeps all 4 balls visible and separated
     */
    const dx = b2.x - b1.x;
    const dy = b2.y - b1.y;
    const distSq = dx * dx + dy * dy;
    const minDist = b1.radius + b2.radius;
    const minDistSq = minDist * minDist;
    
    // If balls are not touching, skip
    if (distSq > minDistSq || distSq < 0.01) return;
    
    const dist = Math.sqrt(distSq);
    const nx = dx / dist;  // Normal vector from b1 to b2
    const ny = dy / dist;
    
    // Separate overlapping balls
    const penetration = minDist - dist;
    const separationAmount = penetration / 2 + 0.5; // Extra margin to prevent re-overlap
    
    b1.x -= nx * separationAmount;
    b1.y -= ny * separationAmount;
    b2.x += nx * separationAmount;
    b2.y += ny * separationAmount;
    
    // Calculate relative velocity
    const dvx = b2.vx - b1.vx;
    const dvy = b2.vy - b1.vy;
    
    // Relative velocity along collision normal
    const dvn = dvx * nx + dvy * ny;
    
    // Only resolve if balls are moving towards each other
    if (dvn < 0) {
        // Elastic collision with equal mass
        const impulse = -dvn; // For equal mass, equal and opposite impulse
        
        b1.vx -= impulse * nx * 0.5;
        b1.vy -= impulse * ny * 0.5;
        b2.vx += impulse * nx * 0.5;
        b2.vy += impulse * ny * 0.5;
    }
}

function isAngleBetween(angle, start, end) {
    /**
     * Check if an angle falls within a start-to-end arc
     * Handles wraparound correctly
     */
    // Normalize all angles to 0-2PI
    const a = ((angle % PI2) + PI2) % PI2;
    const s = ((start % PI2) + PI2) % PI2;
    const e = ((end % PI2) + PI2) % PI2;
    
    if (s < e) {
        // Normal case (no wraparound)
        return a >= s && a <= e;
    } else {
        // Wraparound case (e.g., 350° to 10°)
        return a >= s || a <= e;
    }
}

function calculateRadialPenetration(dist, inner, outer, ballR) {
    /**
     * Calculate how much the ball penetrates the wall
     * Returns positive value if penetrating
     */
    if (dist < inner) {
        // Ball is inside the ring
        return (inner + ballR) - dist;
    } else if (dist > outer) {
        // Ball is outside the ring
        return (outer - ballR + ballR) - dist;
    } else {
        // Ball is in the wall zone - calculate penetration
        const distToInner = dist - inner;
        const distToOuter = outer - dist;
        
        if (distToInner < distToOuter) {
            // Closer to inner edge
            return ballR - distToInner;
        } else {
            // Closer to outer edge
            return ballR - distToOuter;
        }
    }
}

function checkCapCollision(b, r, angle) {
    /**
     * Check collision with the wall end caps (rounded wall edges at gap)
     * Treats them as circular obstacles
     */
    const capX = centerX + Math.cos(angle) * r;
    const capY = centerY + Math.sin(angle) * r;
    
    const dx = b.x - capX;
    const dy = b.y - capY;
    const distSq = dx * dx + dy * dy;
    const capRadius = CONFIG.WALL_WIDTH / 2;
    const minDist = capRadius + b.radius;
    
    if (distSq < minDist * minDist && distSq > 0.01) {
        const dist = Math.sqrt(distSq);
        const nx = dx / dist;
        const ny = dy / dist;
        
        const penetration = minDist - dist;
        
        // Separate
        b.x += nx * penetration * CONFIG.POSITIONAL_CORRECTION;
        b.y += ny * penetration * CONFIG.POSITIONAL_CORRECTION;
        
        // Dampen velocity (touching cap)
        const velDot = b.vx * nx + b.vy * ny;
        if (velDot < 0) {
            b.vx -= velDot * nx * 0.5;
            b.vy -= velDot * ny * 0.5;
        }
    }
}

function checkWin() {
    // Goal Zone - the center green area (much larger for easier access)
    // Using RINGS - 1 instead of RINGS + 2 makes it significantly larger
    const goalR = maxRadius / (CONFIG.RINGS - 0.5);
    let count = 0;
    
    balls.forEach(b => {
        const d = Math.sqrt((b.x - centerX)**2 + (b.y - centerY)**2);
        if(d < goalR) count++;
    });
    
    // Update HUD with balls in goal
    const ballsInGoalText = `${count}/${CONFIG.BALL_COUNT} Balls Secured`;
    document.getElementById('timerBadge').innerText = gameState.timeStr + " | " + ballsInGoalText;
    
    // Win when all balls reach goal
    if(count === CONFIG.BALL_COUNT && !gameState.won) {
        gameState.won = true;
        gameState.playing = false;
        
        const elapsed = Date.now() - gameState.startTime;
        const finalStr = formatTime(elapsed);
        document.getElementById('finalTime').innerText = finalStr;
        
        // Show win screen with delay for visual feedback
        setTimeout(() => {
            document.getElementById('winScreen').classList.remove('hidden');
        }, 300);
    }
}

/**
 * --- RENDERING ---
 */
function loop() {
    // 1. Logic
    updatePhysics();
    updateTimer();

    // 2. Render
    ctx.clearRect(0,0,width,height);
    
    drawBoard();
    drawMaze();
    drawBalls();

    requestAnimationFrame(loop);
}

function drawBoard() {
    // Wood Texture Background
    const grad = ctx.createRadialGradient(centerX, centerY, 10, centerX, centerY, maxRadius*1.2);
    grad.addColorStop(0, '#eecfa1');
    grad.addColorStop(1, '#8d6e63');
    
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,width,height);
    
    // Goal Hole (larger for easier access)
    const goalRadius = maxRadius / (CONFIG.RINGS - 0.5);
    ctx.beginPath();
    ctx.arc(centerX, centerY, goalRadius, 0, PI2);
    ctx.fillStyle = '#1b5e20';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Inner Shadow of hole
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'black';
    ctx.stroke();
    ctx.shadowBlur = 0;
}

function drawMaze() {
    // Drop Shadow for Walls (creates depth)
    ctx.shadowColor = 'rgba(0,0,0,0.4)';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 4;

    walls.forEach(w => {
        ctx.beginPath();
        
        if (w.type === 'arc') {
            // CONCENTRIC RING WALLS
            ctx.arc(centerX, centerY, w.radius, w.startAngle, w.endAngle);
            ctx.lineWidth = w.width;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#4e342e';
            ctx.stroke();
            
            // Inner highlight for 3D effect
            ctx.beginPath();
            ctx.arc(centerX, centerY, w.radius, w.startAngle, w.endAngle);
            ctx.lineWidth = w.width - 4;
            ctx.strokeStyle = '#6d4c41';
            ctx.stroke();
        } else if (w.type === 'radial') {
            // RADIAL BLOCKING WALLS
            const x1 = centerX + Math.cos(w.angle) * w.innerR;
            const y1 = centerY + Math.sin(w.angle) * w.innerR;
            const x2 = centerX + Math.cos(w.angle) * w.outerR;
            const y2 = centerY + Math.sin(w.angle) * w.outerR;
            
            // Main wall line
            ctx.lineWidth = w.width;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#4e342e';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Highlight
            ctx.beginPath();
            ctx.lineWidth = w.width - 4;
            ctx.strokeStyle = '#6d4c41';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
    });

    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
}

function drawBalls() {
    balls.forEach(b => {
        // Drop Shadow
        ctx.beginPath();
        ctx.arc(b.x + 2, b.y + 4, b.radius, 0, PI2);
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.fill();

        // Ball Body
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, PI2);
        
        // Metallic Gradient
        const grad = ctx.createRadialGradient(
            b.x - b.radius*0.3, b.y - b.radius*0.3, b.radius*0.1, 
            b.x, b.y, b.radius
        );
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(0.4, '#cfd8dc');
        grad.addColorStop(1, '#546e7a');
        
        ctx.fillStyle = grad;
        ctx.fill();
        
        // Shine
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(b.x - b.radius*0.3, b.y - b.radius*0.3, 2, 0, PI2);
        ctx.fill();
    });
}

function updateTimer() {
    if(!gameState.playing) return;
    const elapsed = Date.now() - gameState.startTime;
    gameState.timeStr = formatTime(elapsed);
    // Updated in checkWin() to show ball progress
}

function formatTime(ms) {
    const s = Math.floor(ms / 1000);
    const m = Math.floor(s / 60);
    const remS = s % 60;
    return `${m < 10 ? '0'+m : m}:${remS < 10 ? '0'+remS : remS}`;
}

/**
 * --- IOS PERMISSIONS ---
 */
function requestPermissions() {
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
            .then(state => {
                if (state === 'granted') startGame();
                else alert('Tilt controls are required to play.');
            })
            .catch(console.error);
    } else {
        startGame();
    }
}

// Boot
init();
</script>
</body>
</html>